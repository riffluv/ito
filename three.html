<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>カードゲーム背景（three.js モック）</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #04020a; overflow: hidden; }
    /* ほんのりビネット（雰囲気調整のCSSオーバーレイ） */
    .vignette {
      position: fixed; inset: 0; pointer-events: none;
      background: radial-gradient(120% 80% at 50% 45%, rgba(180,120,255,0.06) 0%, rgba(20,10,30,0.06) 35%, rgba(0,0,0,0.5) 80%, rgba(0,0,0,0.9) 100%);
      mix-blend-mode: screen;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="vignette"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';

    // ------------------------------------------------------------
    // 基本セットアップ
    // ------------------------------------------------------------
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(1.75, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // ✅ エラー対策: 先に Scene を定義
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 10);

    // ------------------------------------------------------------
    // 共通: ソフト円テクスチャ（星＆ノードで共用）
    // ------------------------------------------------------------
    function makeCircleTexture(size = 64){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      g.addColorStop(0, 'rgba(255,255,255,1)');
      g.addColorStop(0.35, 'rgba(255,255,255,0.8)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
      const tex = new THREE.CanvasTexture(c);
      tex.magFilter = THREE.LinearFilter;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      return tex;
    }

    // ------------------------------------------------------------
    // 1) ネビュラ（シェーダー）
    // ------------------------------------------------------------
    const nebulaUniforms = {
      u_time: { value: 0 },
      u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      u_aspect: { value: window.innerWidth / window.innerHeight },
    };

    const nebulaMaterial = new THREE.ShaderMaterial({
      uniforms: nebulaUniforms,
      vertexShader: /* glsl */`
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying vec2 vUv;
        uniform float u_time; 
        uniform vec2  u_resolution;
        // --------------------------------------------
        // Simplex noise (Ashima, Public Domain)
        // --------------------------------------------
        vec3 mod289(vec3 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
        vec2 mod289(vec2 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
        vec3 permute(vec3 x){ return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v){
          const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
          vec2 i  = floor(v + dot(v, C.yy));
          vec2 x0 = v - i + dot(i, C.xx);
          vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
          vec4 x12 = x0.xyxy + C.xxzz;
          x12.xy -= i1;
          i = mod289(i);
          vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
          m = m*m; m = m*m;
          vec3 x = 2.0 * fract(p * C.www) - 1.0;
          vec3 h = abs(x) - 0.5;
          vec3 ox = floor(x + 0.5);
          vec3 a0 = x - ox;
          m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
          vec3 g; g.x  = a0.x * x0.x + h.x  * x0.y;
                   g.y  = a0.y * x12.x + h.y  * x12.y;
                   g.z  = a0.z * x12.z + h.z  * x12.w;
          return 130.0 * dot(m, g);
        }
        float fbm(vec2 st){
          float v = 0.0;
          float a = 0.55;
          mat2 rot = mat2(0.8, -0.6, 0.6, 0.8);
          for(int i=0;i<6;i++){
            v += a * snoise(st);
            st = rot * st * 2.0 + 0.1;
            a *= 0.55;
          }
          return v;
        }
        void main(){
          vec2 uv = vUv;
          vec2 p = (uv - 0.5) * vec2(u_resolution.x / u_resolution.y, 1.0);
          float t = u_time * 0.045;
          float n = fbm(p * 1.2 + vec2(t, -t*0.6));
          vec3 colA = vec3(0.12, 0.02, 0.20);
          vec3 colB = vec3(0.71, 0.45, 1.00);
          vec3 colC = vec3(0.23, 0.09, 0.36);
          float glow = smoothstep(0.15, 0.75, n * 0.5 + 0.5);
          vec3 col = mix(colA, colC, glow);
          col = mix(col, colB, pow(max(n,0.0), 2.0) * 0.55);
          float r = length(p);
          col += 0.15 * vec3(0.7, 0.3, 1.0) * smoothstep(0.8, 0.0, r);
          col *= 1.0 - smoothstep(0.6, 1.1, r);
          gl_FragColor = vec4(col, 1.0);
        }
      `,
      depthWrite: false
    });

    const nebula = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), nebulaMaterial);
    nebula.position.z = -4.0;
    scene.add(nebula);

    // ------------------------------------------------------------
    // 2) スターフィールド（微妙に瞬く）
    // ------------------------------------------------------------
    const starGeom = new THREE.BufferGeometry();
    const starCount = 1400;
    const positions = new Float32Array(starCount * 3);
    const phases = new Float32Array(starCount);

    for(let i=0;i<starCount;i++){
      const r = THREE.MathUtils.randFloat(20, 120);
      const theta = Math.acos(THREE.MathUtils.randFloatSpread(2));
      const phi = THREE.MathUtils.randFloat(0, Math.PI * 2);
      positions[i*3+0] = r * Math.sin(theta) * Math.cos(phi);
      positions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
      positions[i*3+2] = r * Math.cos(theta);
      phases[i] = Math.random() * Math.PI * 2;
    }

    starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starGeom.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

    const stars = new THREE.Points(starGeom, new THREE.PointsMaterial({
      size: 0.7, sizeAttenuation: true, transparent: true,
      depthWrite: false, map: makeCircleTexture(64), blending: THREE.AdditiveBlending,
      opacity: 0.9
    }));
    scene.add(stars);

    // ------------------------------------------------------------
    // 3) 幾何学的サークル/ライン（強化版・魔方陣）
    // ------------------------------------------------------------
    const glyphGroup = new THREE.Group();
    scene.add(glyphGroup);

    // 発光ライン系マテリアル
    const lineMat = new THREE.LineBasicMaterial({ color: 0xE7C8FF, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
    const thinMat = new THREE.LineBasicMaterial({ color: 0xC5A3FF, transparent: true, opacity: 0.55, blending: THREE.AdditiveBlending });
    const dashMat = new THREE.LineDashedMaterial({ color: 0xFFFFFF, dashSize: 0.22, gapSize: 0.12, scale: 1, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending });
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xB07BFF, transparent: true, opacity: 0.14, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });

    function circleGeometry(r=1, seg=256){
      const pts = [];
      for(let i=0;i<=seg;i++){
        const a = (i/seg) * Math.PI * 2;
        pts.push(new THREE.Vector3(Math.cos(a)*r, Math.sin(a)*r, 0));
      }
      return new THREE.BufferGeometry().setFromPoints(pts);
    }
    function arcGeometry(r=1, a0=0, a1=Math.PI/2, seg=96){
      const pts = [];
      for(let i=0;i<=seg;i++){
        const a = THREE.MathUtils.lerp(a0, a1, i/seg);
        pts.push(new THREE.Vector3(Math.cos(a)*r, Math.sin(a)*r, 0));
      }
      return new THREE.BufferGeometry().setFromPoints(pts);
    }
    function polygonGeometry(n=3, r=1){
      const pts = [];
      for(let i=0;i<=n;i++){
        const a = (i % n) / n * Math.PI*2 - Math.PI/2;
        pts.push(new THREE.Vector3(Math.cos(a)*r, Math.sin(a)*r, 0));
      }
      return new THREE.BufferGeometry().setFromPoints(pts);
    }
    function starPolygonGeometry(n=5, rOuter=2, rInner=1){
      const pts = [];
      const N = n*2;
      for(let i=0;i<=N;i++){
        const r = (i % 2 === 0) ? rOuter : rInner;
        const a = i / N * Math.PI*2 - Math.PI/2;
        pts.push(new THREE.Vector3(Math.cos(a)*r, Math.sin(a)*r, 0));
      }
      return new THREE.BufferGeometry().setFromPoints(pts);
    }
    function addDashedCircle(r){
      const l = new THREE.Line(circleGeometry(r), dashMat);
      l.computeLineDistances();
      glyphGroup.add(l); return l;
    }
    function addRadialTicks(rIn, rOut, count, mat=thinMat){
      const grp = new THREE.Group();
      for(let i=0;i<count;i++){
        const a = i / count * Math.PI*2;
        const p0 = new THREE.Vector3(Math.cos(a)*rIn, Math.sin(a)*rIn, 0);
        const p1 = new THREE.Vector3(Math.cos(a)*rOut, Math.sin(a)*rOut, 0);
        const g = new THREE.BufferGeometry().setFromPoints([p0,p1]);
        grp.add(new THREE.Line(g, mat));
      }
      glyphGroup.add(grp);
      return grp;
    }

    // レイヤー構成
    const layerBack = new THREE.Group();
    const layerMid  = new THREE.Group();
    const layerFore = new THREE.Group();
    glyphGroup.add(layerBack, layerMid, layerFore);

    // 背面グローリング
    const glow1 = new THREE.Mesh(new THREE.RingGeometry(3.6, 4.2, 256), glowMat); glow1.position.z = -0.02; layerBack.add(glow1);
    const glow2 = new THREE.Mesh(new THREE.RingGeometry(2.6, 3.1, 256), glowMat); glow2.position.z = -0.02; layerBack.add(glow2);

    // メイン円 + ダッシュ円
    [1.25, 2.05, 2.95, 4.0].forEach((r,i)=>{
      const m = (i%2===0) ? lineMat : thinMat;
      layerMid.add(new THREE.Line(circleGeometry(r), m));
    });
    addDashedCircle(1.65);
    addDashedCircle(3.5);

    // ポリゴン（正三角形 & 五芒星）
    layerMid.add(new THREE.Line(polygonGeometry(3, 1.05), thinMat));
    layerMid.add(new THREE.Line(starPolygonGeometry(5, 1.9, 0.8), lineMat));

    // ルーン風の円弧
    const arcMat = new THREE.LineBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const arcs = [ [2.95, -0.1, 0.9], [2.95, 1.2, 2.0], [2.05, 2.4, 3.1], [1.25, -2.2, -1.2], [3.5, 3.4, 4.6] ];
    arcs.forEach(([r,a0,a1])=> layerFore.add(new THREE.Line(arcGeometry(r, a0, a1, 96), arcMat)));

    // ラジアル目盛り
    addRadialTicks(1.95, 2.15, 36, thinMat);
    addRadialTicks(2.85, 3.05, 48, thinMat);

    // ノード（光点）
    const nodeTex = makeCircleTexture(128);
    const nodeMat = new THREE.SpriteMaterial({ map: nodeTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, color: 0xFFFFFF, opacity: 0.95 });
    function addNode(x,y,s=0.1, parent=layerFore){ const sp = new THREE.Sprite(nodeMat.clone()); sp.position.set(x,y,0.01); sp.scale.setScalar(s); parent.add(sp); return sp; }
    const nodeAngles = [0, Math.PI/3, Math.PI*2/3, Math.PI, Math.PI*4/3, Math.PI*5/3];
    nodeAngles.forEach(a=> addNode(Math.cos(a)*2.95, Math.sin(a)*2.95, 0.14));

    // オービター（ゆっくり周回する火花）
    const orbiters = [];
    function addOrbiter(radius, speed, size){
      const s = new THREE.Sprite(nodeMat.clone());
      s.scale.setScalar(size); s.position.z = 0.02; layerFore.add(s);
      orbiters.push({s, r: radius, a: Math.random()*Math.PI*2, v: speed});
    }
    addOrbiter(1.65, 0.25, 0.11);
    addOrbiter(2.05, -0.18, 0.09);
    addOrbiter(3.5, 0.12, 0.12);

    glyphGroup.rotation.z = 0.03;

    // ------------------------------------------------------------
    // 4) 背景用: カメラ固定（操作なし）
    // ------------------------------------------------------------

    // ------------------------------------------------------------
    // 5) レンダーループ
    // ------------------------------------------------------------
    const clock = new THREE.Clock();
    function animate(){
      const t = clock.getElapsedTime();
      nebulaUniforms.u_time.value = t;
      stars.rotation.y = t * 0.004;
      stars.rotation.x = Math.sin(t * 0.05) * 0.015;
      layerBack.rotation.z =  t * 0.005;
      layerMid.rotation.z  = -t * 0.007;
      layerFore.rotation.z =  t * 0.010;
      for(const o of orbiters){ o.a += o.v * 0.01; o.s.position.set(Math.cos(o.a)*o.r, Math.sin(o.a)*o.r, 0.02); }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // ------------------------------------------------------------
    // リサイズ
    // ------------------------------------------------------------
    function onResize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h; camera.updateProjectionMatrix();
      nebulaUniforms.u_resolution.value.set(w, h);
    }
    window.addEventListener('resize', onResize);

    // ------------------------------------------------------------
    // 簡易セルフテスト（コンソールに結果を出力）
    // ------------------------------------------------------------
    (function runTests(){
      console.group('[背景モック: 自動テスト]');
      console.assert(!!scene && scene.isScene, 'scene が初期化されている');
      console.assert(!!camera && camera.isCamera, 'camera が初期化されている');
      console.assert(!!stars && stars.isPoints, 'stars が作成されている');
      console.assert(glyphGroup.children.length > 0, '魔方陣パーツが追加されている');
      console.groupEnd();
    })();
  </script>
</body>
</html>
