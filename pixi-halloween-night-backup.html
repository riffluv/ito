<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>HD-2D Mock (Three.js)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;background:#cfe0ee;overflow:hidden}
  canvas{display:block}
  .note{position:fixed;left:10px;bottom:10px;color:#fff;background:rgba(0,0,0,.35);
        padding:6px 8px;border-radius:8px;font:12px/1.2 system-ui}
</style>
</head>
<body>
<div class="note">HD-2D風モック：見下ろし + Bloom + 擬似ティルトシフト</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/ShaderPass.js';

// === 基本 ===
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xb6cde0, 70, 260);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;      // ← 互換性重視（暗転回避）
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(35, 24, 35);
camera.lookAt(0,0,0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.minDistance = 18;
controls.maxDistance = 70;
controls.minPolarAngle = 0.7;
controls.maxPolarAngle = 1.3;

// === ライト ===
scene.add(new THREE.HemisphereLight(0xcfe6ff, 0x4d3d2f, 0.7));
const sun = new THREE.DirectionalLight(0xfff7e0, 1.2);
sun.position.set(60,80,20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left = -90; sun.shadow.camera.right = 90;
sun.shadow.camera.top = 90;   sun.shadow.camera.bottom = -90;
scene.add(sun);

// === タイル地面（CanvasTexture）===
function makeTilesTexture(size=512, tile=64){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#a29688'; ctx.fillRect(0,0,size,size);
  ctx.strokeStyle = 'rgba(0,0,0,.16)'; ctx.lineWidth = 3;
  for(let x=0;x<=size;x+=tile){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,size);ctx.stroke();}
  for(let y=0;y<=size;y+=tile){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(size,y);ctx.stroke();}
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(30,30);
  tex.anisotropy = 8;
  return tex;
}
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(240, 240),
  new THREE.MeshStandardMaterial({ map: makeTilesTexture(), roughness:0.9 })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// === 植え込みリング ===
function hedgeRing(r=20, n=48){
  const g = new THREE.Group();
  const bushGeo = new THREE.SphereGeometry(1.25, 12, 12);
  const bushMat = new THREE.MeshStandardMaterial({ color:0x4aa84f, roughness:0.95 });
  for(let i=0;i<n;i++){
    const a = i/n*Math.PI*2;
    const m = new THREE.Mesh(bushGeo, bushMat);
    m.position.set(Math.cos(a)*r, 1.25, Math.sin(a)*r);
    m.castShadow = true; m.receiveShadow = true;
    g.add(m);
  }
  return g;
}
scene.add(hedgeRing(22,64));
scene.add(hedgeRing(11,40));

// === 簡易噴水 + 水しぶき ===
function createFountain(){
  const g = new THREE.Group();
  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(6,6,1.6,40),
    new THREE.MeshStandardMaterial({ color:0xbdb5a8, roughness:0.9 })
  );
  base.position.y = 0.8; base.castShadow = true; base.receiveShadow = true;
  g.add(base);

  const water = new THREE.Mesh(
    new THREE.CircleGeometry(5.2,48),
    new THREE.MeshPhysicalMaterial({ color:0x70ccff, roughness:0.07, transmission:0.85, thickness:0.35, transparent:true, opacity:0.95 })
  );
  water.rotation.x = -Math.PI/2; water.position.y = 1.62; g.add(water);

  const pillar = new THREE.Mesh(
    new THREE.CylinderGeometry(0.7,1.6,4,24),
    new THREE.MeshStandardMaterial({ color:0xbdb5a8, roughness:0.8 })
  );
  pillar.position.y = 3.6; pillar.castShadow = true; pillar.receiveShadow = true; g.add(pillar);

  // 水しぶき（Points）
  const N=500;
  const pos = new Float32Array(N*3), vel = new Float32Array(N*3), life = new Float32Array(N);
  function reset(i){
    const r = 0.4 + Math.random()*4.6, a = Math.random()*Math.PI*2;
    pos[i*3]=Math.cos(a)*r; pos[i*3+1]=1.7; pos[i*3+2]=Math.sin(a)*r;
    vel[i*3]=Math.cos(a)*0.3; vel[i*3+1]=4+Math.random()*6; vel[i*3+2]=Math.sin(a)*0.3;
    life[i]=1.5+Math.random()*1.8;
  }
  for(let i=0;i<N;i++) reset(i);
  const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({ color:0xe8f7ff, size:0.08, sizeAttenuation:true, transparent:true, opacity:0.9 });
  const points = new THREE.Points(geo, mat); g.add(points);

  const light = new THREE.PointLight(0x9fd3ff, 0.9, 35, 2); light.position.set(0,4.5,0); g.add(light);

  g.userData.update = (dt)=>{
    for(let i=0;i<N;i++){
      life[i]-=dt;
      pos[i*3]+=vel[i*3]*dt; pos[i*3+1]+=vel[i*3+1]*dt; pos[i*3+2]+=vel[i*3+2]*dt;
      vel[i*3+1]-=9.81*0.9*dt;
      if(life[i]<=0 || pos[i*3+1]<0.1) reset(i);
    }
    geo.attributes.position.needsUpdate = true;
    water.material.opacity = 0.9 + Math.sin(performance.now()*0.004)*0.04;
  };
  return g;
}
const fountain = createFountain();
scene.add(fountain);

// === ランプポスト ===
function createLamp(){
  const g = new THREE.Group();
  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.25,0.35,8,12),
    new THREE.MeshStandardMaterial({ color:0x3c322d, roughness:0.8 })
  );
  pole.position.y=4; pole.castShadow=true; pole.receiveShadow=true; g.add(pole);
  const bulb = new THREE.Mesh(
    new THREE.SphereGeometry(0.35,12,12),
    new THREE.MeshStandardMaterial({ color:0x111111, emissive:0xfff0c8, emissiveIntensity:2.5 })
  );
  bulb.position.y=8.3; g.add(bulb);
  const l = new THREE.PointLight(0xffe6b0, 1.1, 24, 2); l.position.y=8.3; l.castShadow=true; g.add(l);
  return g;
}
[[15,15],[-15,15],[15,-15],[-15,-15],[0,20],[20,0],[0,-20],[-20,0]].forEach(([x,z])=>{
  const lamp = createLamp(); lamp.position.set(x,0,z); scene.add(lamp);
});

// === 2D風キャラ（Sprite）===
function makeSprite(){
  const c = document.createElement('canvas'); c.width=c.height=64;
  const ctx = c.getContext('2d');
  ctx.fillStyle='#0000'; ctx.fillRect(0,0,64,64);
  ctx.fillStyle='#f08c2e'; ctx.fillRect(26,8,12,10); // 髪
  ctx.fillStyle='#ffd7b3'; ctx.fillRect(28,16,8,8);  // 顔
  ctx.fillStyle='#2d6cdf'; ctx.fillRect(26,24,12,14);// 服
  ctx.fillStyle='#e0e0e0'; ctx.fillRect(26,38,12,6); // 脚
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = tex.magFilter = THREE.NearestFilter;
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map:tex, transparent:true }));
  sp.scale.set(1.3,1.8,1); sp.position.set(10,1.0,10);
  return sp;
}
scene.add(makeSprite());

// === ポストプロセス（安全版：Bloom + 擬似ティルトシフトのみ）===
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.7, 0.9, 0.85);
composer.addPass(bloom);

// 本格的なDOFは環境により真っ暗になることがあるので、
// ここでは「上下にいくほど強くなる簡易ぼかし」をシェーダで再現
const TiltShift = {
  uniforms:{
    tDiffuse:{value:null},
    amount:{value:0.6},    // ぼかし強さ
    center:{value:0.5},    // シャープに保つ中心ライン（0〜1）
    range:{value:0.35},    // シャープ領域の幅
    resolution:{value:new THREE.Vector2(innerWidth, innerHeight)}
  },
  vertexShader:`
    varying vec2 vUv;
    void main(){ vUv=uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }
  `,
  fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float amount, center, range;
    uniform vec2 resolution;
    varying vec2 vUv;
    // 簡易ガウシアン（5tap）
    vec4 blur(vec2 uv, float r){
      vec2 px = vec2(1.0)/resolution * r;
      vec4 c = texture2D(tDiffuse, uv) * 0.4;
      c += texture2D(tDiffuse, uv + vec2( px.x, 0.0)) * 0.15;
      c += texture2D(tDiffuse, uv + vec2(-px.x, 0.0)) * 0.15;
      c += texture2D(tDiffuse, uv + vec2(0.0,  px.y)) * 0.15;
      c += texture2D(tDiffuse, uv + vec2(0.0, -px.y)) * 0.15;
      return c;
    }
    void main(){
      float d = abs(vUv.y - center);
      float edge = smoothstep(range*0.6, range, d);  // 中央はシャープ、上下でボケ
      float r = edge * amount * 6.0;                 // サンプル半径
      vec4 col = mix(texture2D(tDiffuse, vUv), blur(vUv, r), edge);
      gl_FragColor = col;
    }
  `
};
const tilt = new ShaderPass(TiltShift);
composer.addPass(tilt);

// === ループ ===
let last = performance.now();
function tick(){
  const now = performance.now();
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  controls.update();
  if (fountain.userData.update) fountain.userData.update(dt);

  composer.render();
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
  tilt.uniforms.resolution.value.set(innerWidth, innerHeight);
});
</script>
</body>
</html>