依頼サマリ

対象領域: 観戦モードとホスト「呼び込み（席復帰）」フローの再設計・実装
目的: 「ホストがリセットして waiting になっているのに観戦者が席へ戻れない」「ページ更新が必要」等の根絶。クライアント局所状態（leavingRef/sessionStorage/多重リトライ）依存を削減し、サーバー主導・冪等な復帰に移行
非目標: ゲームロジック本体や Presence 設計（RTDB 唯一ソース）の変更、課金/決済フロー追加（発生しません）
設計方針（要点）

サーバー主導の受理: 復帰要求は Firestore に upsert、Cloud Functions が waiting 遷移時/要求作成時に受理して座席を確保する
クライアントは受動: 観戦 UI は「要求送信→players 購読で自身が現れたら完了」を基準に遷移。能動的 join リトライは最小化
段階導入: フラグ NEXT_PUBLIC_RECALL_V2=1 で新設計を有効化。OFF では現行維持
リポ方針順守: Firestore/RTDB 書き込みは lib/game/service.ts 経由、Presence は RTDB のみを情報源
データモデル（Firestore）

コレクション: rooms/{roomId}/rejoinRequests/{uid}
createdAt: Timestamp, displayName: string|null, status: "pending" | "accepted" | "rejected", source: "manual" | "auto"
TTL または清掃バッチで24h以上を削除（運用で調整可）
Functions 実装（新規）

追加: functions/src/rejoin.ts
トリガ:
onCreate(rooms/{roomId}/rejoinRequests/{uid}): ルームが waiting なら即受理、そうでなければ pending のまま
onUpdate(rooms/{roomId}): status が waiting に遷移したら rejoinRequests の pending を走査して受理
受理ロジック（冪等・最小 RW）
トランザクションで実行
players/{uid} が無ければ作成（PlayerDoc 準拠、avatar 重複回避は簡易で可）
deal.players へ追加、order.total 更新（存在する場合のみ）
lastActiveAt 更新
rejoinRequests/{uid}.status = "accepted"
失敗時
3回程度まで指数リトライ→それでも失敗は "rejected" + ログ/トレース
コストとパフォーマンス
1件当たり 読み取り ~2、書き込み ~3 想定。コールドスタート回避が必要なら min-instances: 1 を設定（任意）
クライアント改修（RECALL_V2 有効時のみ）

サービス層 lib/game/service.ts
requestSeat(roomId, uid, displayName?: string|null, source?: "manual"|"auto"): rejoinRequests/{uid} を upsert（status="pending", createdAt=serverTimestamp()）
cancelSeatRequest(roomId, uid)（任意）
観戦 UI app/rooms/[roomId]/page.tsx
「席に戻れるか試す」押下時は requestSeat(..., "manual") のみ実行。ボタンは申請中 disable/スピナー表示
room.status === "waiting" かつ 観戦中 かつ players に自身が居ない場合、初回のみ requestSeat(..., "auto")
自身が players に現れたら観戦 UI を閉じ、ensureMember/assignNumberIfNeeded を（必要なら）呼ぶ
現行の能動 joinRoomFully リトライは RECALL_V2 では停止（fallback 目的の最小限に限定）
useRoomState.ts
RECALL_V2 分岐で sessionStorage pendingRejoin 依存や積極リトライを抑止
isMember ＝ players に自身が存在、を唯一基準として遷移
バナー文言/UX
申請中インジケータ（最大 10–15 秒）
タイムアウト時はガイダンス（「ホスト準備中の可能性。少し待って再試行」）
既存 hotfix の踏襲
leavingRef による弾きを waiting 移行時に解除（現行修正は維持）
トレース/メトリクス

lib/utils/trace.ts 経由で追加
spectator.requestSeat（roomId,source）
spectator.recallAccepted / spectator.recallRejected
spectator.recallTimeout
bumpMetric
recall.requested, recall.accepted, recall.rejected
docs/OPERATIONS.md に監視手順追記
セキュリティルール

Firestore ルールに rejoinRequests/{uid} を「本人のみ作成/更新可」に追加（request.auth.uid == uid）
読み取りは部屋参加者/観戦者に限定（現行ポリシーに準拠）
テスト（優先シナリオ）

E2E（Playwright）
S1: ラウンド中 URL直打ち観戦 → ホスト reset → 自動復帰（3秒以内）
S2: 観戦で「席に戻れるか試す」→ 申請作成 → 受理後に参加状態へ遷移
S3: タイムアウト表示・再試行ガイダンス
S4: フラグ OFF で現行動作維持
単体/結合（Jest）
requestSeat の upsert
Functions の受理（pending→accepted）＋deal.players/order.total 更新の冪等性
競合（同時押下/多重申請）で一度だけ受理される
ロールアウト

ステージング: NEXT_PUBLIC_RECALL_V2=1 → 主要シナリオ通過
本番: 時間帯を選びフラグ ON（段階的）
監視: recall.* メトリクス、エラーログ/Sentry
ロールバック: フラグ OFF（即時復帰可能）。Functions は残しても無害
変更ファイル（想定）

追加: functions/src/rejoin.ts
変更: lib/game/service.ts（新 API）、app/rooms/[roomId]/page.tsx（観戦 UI ハンドラ/自動申請/ボタン状態）、lib/hooks/useRoomState.ts（RECALL_V2 分岐）
ドキュメント: docs/OPERATIONS.md
セキュリティ: firestore.rules（rejoinRequests 追記）
実装メモ（関数疑似コード）

onCreate rejoinRequests
取得: room, requestDoc
if room.status === "waiting": 受理処理（Tx）
else: 何もしない（pending 維持）
onUpdate rooms（status 変更）
if new.status === "waiting": rejoinRequests の status=="pending" を列挙→逐次または小バッチで受理（Tx）
受理処理（Tx）
players/{uid} upsert（存在すれば skip）
deal.players へ uid 追加（重複チェック）、order.total 更新
room.lastActiveAt 更新
request.status="accepted"
受け入れ基準

ホスト reset 後、観戦者はページ更新無しで 5秒以内に復帰（自動 or 手動）
二重申請や多重クリックで不整合が起きない（冪等）
Presence は RTDB のみをソースに維持（本変更で破壊しない）
フラグ OFF の既存動作が回帰
パフォーマンス/課金

クライアント: 申請時の Firestore 書き込み1回のみ。常時購読は既存 players のまま
サーバー: 1リクエスト ≈ 読み取り ~2 / 書き込み ~3（概算）。TTL 清掃でストレージ軽微
決済は関与なし（購買は走りません）
以上。PR は Functions → サービス層 → UI の順で小さめに分割し、各段でテスト/計測を通して進めてください。