以下は、中央カードを Pixi HUD 化しつつ既存の振る舞い（ドラッグ＆ドロップ／リビール演出／音／アクセシビリティ）を完全に引き継ぐための実装指示です。既存背景 Pixi 化済み、カード本体は DOM 実装 (CardRenderer→GameCard) のままという現状を前提にしています。

1. 現状整理（コードリファレンス）
中央盤ロジック：components/CentralCardBoard.tsx 全体。
DnD kit の SortableItem が DOM カード (CardRenderer) を包んでおり、DragOverlay でも DOM を描画。
背景はまだ DOM (BoardFrame) で border を描画している（Pixi 化予定）。
カード描画：components/ui/CardRenderer.tsx → GameCard（DOM）。
状態計算は lib/cards/logic.ts。
ViewModel 変換は components/ui/cardViewModel.ts。
共通スタイル：components/cards/card.styles.ts／BaseCard.tsx。
空スロット：components/cards/EmptyCard.tsx。
DnD ハンドラ：components/hooks/useDropHandler.ts、マグネット関連ロジックは computeMagnetTransform（中央盤内）。
再利用するべきドメインロジック

computeCardState（数値表示タイミング・色分け・境界判定）。
createBoardCardViewModel（名前・数値・variant/flipped 等）。
これらは Pixi 版でもそのまま使い、レンダリング層だけ差し替える。

2. ゴール
中央カード（中央盤・WaitingArea を含む）を Pixi レイヤー上で描画。DOM カードはレイアウト用プレースホルダとして残す。
既存のゲーム状態・アニメーション要件（flip、成功／失敗色、境界リング、成否時のグロー、番号テキスト、LOW/HIGH ラベル）を維持。
ドラッグ＆ドロップ、マグネット、DragOverlay、リビール／Finished transition、サウンドを既存仕様通りに動作させる。
Pixi カードは rotate(180°) のフリップアニメを提供。useReducedMotionPreference() が true の場合は即時切り替え。
アクセシビリティ確保：DOM 側に aria-live 用テキスト（VisuallyHidden）を残し、Pixi カードにも accessible 設定。
フォールバック：Pixi 初期化失敗時には DOM カードに切り替え可能。
パフォーマンス：60fps 前後を維持。DPR は 1.0〜1.5 にクランプ、フィルタ 2 枚以内。
3. 実装ステップ
STEP 0: フラグ設計
CentralCardBoard.tsx に const PIXI_CARD_ENABLED = true のようなトグルを用意。
以降の変更はこのフラグで ON/OFF できるように実装する（開発中に DOM 版と比較できるようにする）。
STEP 1: Pixi レイヤー構造
usePixiHudLayer("central-card-board", { zIndex: 70, interactive: true }) でコンテナ取得。
Pixi コンテナ構造案：
boardLayer (Pixi container)
  ├─ backgroundLayer (Graphics)      // ボード枠
  ├─ slotHighlightLayer (Graphics)  // マグネット等のオーバーレイ
  ├─ cardsLayer (Container)         // 静止カード群
  └─ dragLayer (Container)          // ドラッグ中の 1 枚
usePixiLayerLayout(boardContainerRef, boardLayer, ...) を使い、中央盤 DOM の getBoundingClientRect() と devicePixelRatio を追跡。背景の位置合わせにも利用。
背景グラフィックスは lib/pixi/centralBoardBackground.ts を作成し、drawCentralBoardBackground(pixi, graphics, { width, height, active }) を実装（Battle Records 版を踏襲）。
STEP 2: DOM プレースホルダ（レイアウト測定）
DOM の SortableItem／BoardFrame／EmptyCard は 非表示（visibility: hidden or opacity: 0）にしてレイアウトだけ維持する。
各カードスロットに ref を渡し、getBoundingClientRect() をフレーム毎 or ResizeObserver で取得。
useSlotMetrics(cardId) フックを作り、Map<string, SlotMetrics> を pixiCardStore に共有。
DnD kit の transform は DOM 上だけに掛かるので、slotRef.getBoundingClientRect() だけで移動後の位置が取れる。
スロットが空の場合も座標が必要：EmptyCard の wrapper div に ref 付与。
STEP 3: Pixi カードクラス
lib/pixi/cards/CentralCardSprite.ts（仮）を新規作成。

constructor(pixi, assets, viewModel) で Container を組み立て。
部品：背景（NineSlice or Graphics）、上部番号ラベル、中央テキスト、下部プレイヤー名、グロウ用 filters。
update(viewModel: CardViewModel, opts) で状態変更を差分適用。
Flip アニメ：variant === "flip" かつ flipped 変化時、gsap.to(container.scale, { x: 0, duration: 0.16, onComplete: () => swapText(); ... }) → scale.x = 1 で回転を再現。useReducedMotionPreference true の場合は即座に表示切替。
サウンド：useSoundEffect("card_flip") を CentralCardBoard で呼び、フリップ検知時に発火。Pixi 側はイベント待ちしない。
色分け：state ごとに border 色／outer glow を filters か Graphics で切り替える。successLevel === "final" の時だけ強めのグロー。
境界 (boundary) のカードは周りに淡いアンバーリングを表示（Graphics で 2px の枠）。
waitingInCentral true の場合は文字色・border を既存 DOM と同じに。
フォント：

Web フォントは使わず、TextStyle に fontFamily: "-apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', system-ui, sans-serif" を指定。
数値フォントサイズは getNumberFontSize のロジックを流用（CardViewModel.number の桁数で調整）。
Clue テキストは 2 行までに収める（wordWrapWidth をカード幅 - padding で指定）。
DPR 対応：pixi.settings.RESOLUTION = Math.min(window.devicePixelRatio, 1.5) を PixiHudStage 側ですでにセットしているので、カード内でのピクセル指定は layout.dpr を掛けて補正する。

STEP 4: CentralCardBoard 側ロジック統合
CardRenderer 呼び出し部 (line ~311) を以下に置換：
PIXI_CARD_ENABLED true の場合はプレースホルダ div（ref 付き）だけを返し、Pixi カード描画用 registerCardSlot(cardId, slotRef) を呼ぶ。
false の場合のみ従来の <SortableItem><CardRenderer/></SortableItem> を返す。
DragOverlay は Pixi モードでは null を返す。ドラッグ中のカードは dragLayer で制御。
onDragStart で setActiveId→pixiCardStore.startDrag(cardId)
onDragMove で event.delta と event.activatorEvent からポインタ座標を取得し、dragLayer のカード位置を更新 (Pixi.Application.renderer.events.pointer.x/y)。
onDragEnd/Cancel で pixiCardStore.finishDrag(cardId)→cardsLayer に戻す。
Magnet のハイライトは magnetSnapshot を監視し、slotHighlightLayer に半透明の枠を描画。magnetStrength（0〜1）でスケール／アルファを可変。
Reveal／Finished 時の再描画：useEffect で cardViewModelMap を生成し、pixiCardStore.sync(viewModels) に渡す。
CardViewModel には variant, flipped, state, successLevel などが含まれる。
useReducedMotionPreference() の値を Pixi ストアに渡し、flip アニメの有無を制御。
サウンド：useSoundEffect("card_flip") を CentralCardBoard で呼び、Pixi カードから onFlipStateChange コールバックを受けた時に playCardFlip()。
STEP 5: WaitingArea との整合
WaitingArea も Pixi 化する場合、中央カードと同じ createWaitingCardViewModel を使い、別レイヤー（例：waiting-area-layer）で描画する。
トグルで DOM 版と切り替えられるようにする。
ドラッグ返却 (returnDropZoneId) は DOM のドロップゾーンが必要なので、返却用 div は残しつつ Pixi 側で視覚表示を行う。
STEP 6: フォールバック
PixiCardController.init() が失敗した場合は例外を握り、PIXI_CARD_ENABLED = false とみなして DOM モードで描画する。
CentralCardBoard の内部状態 (useState) で Pixi 初期化成功を保持し、条件付きレンダリングに利用。
エラーは logError("pixi-card-init", err) で記録。
4. 実装チェックリスト
視覚：
clue 入力前 → 黒背景／白枠／テキスト「(連想待ち)」。
clue 確定 → 銀枠／ready テイスト。
Reveal 中 → flip アニメで数値表示。
成功時 → ゴールド枠＋グロー。
失敗時 → 赤枠＋失敗境界カードのリング。
Drag 中 → dragLayer 上でカードが追従し、元位置はプレースホルダのみ。
DnD：
ドロップ可否に応じて slotHighlightLayer がフェード、notify 文言は変更なし。
Magnet 対象で吸着演出（スケール／グロー）。
性能：
npm run lint, npm run build。
DevTools Performance で 30 秒計測し、fps, INP の劣化が ±10% 以内。
devicePixelRatio を 1.5 に固定しても 60fps 近辺。
アクセシビリティ：
Pixi カードに cardContainer.accessible = true, accessibleTitle へ player.name＋clue＋number。
DOM の VisuallyHidden で読み上げテキストを従来通り更新。
サウンド：flip 開始時・終了時に従来通り card_flip が鳴る（useSoundEffect)。
フォールバック：Pixi を無効化した場合（PIXI_CARD_ENABLED=false）でも DOM 版が正しく動作。
5. 注意点・ベストプラクティス
PixiHudStage 側の resolution は既に Math.min(DPR, 2) になっているが、カード用の canvas サイズ計算時に layout.dpr を掛け忘れない。
フィルタは BlurFilter 等を使わず、graphics×アルファで実装。どうしても必要な場合は 2 枚以内。
dragLayer の update は requestAnimationFrame で throttle（DnD move イベントは高頻度）。
cacheAsBitmap はカードが頻繁に変わるので使用しない。
グローバル状態管理（pixiCardStore）には useRef＋ Map を使い、React 再レンダー毎に再初期化しないようにする。
既存の computeMagnetTransform の戻り値 (dx/dy) を Pixi カード位置にも適用すると、DOM／Pixi で挙動がずれない。
単体テストは無いが、CardViewModel 変換→Pixi 更新部分は unit 化しやすいよう純関数を分離する。
6. 最終確認フロー
Pixi モード ON → ルーム作成 → カード配布 → clue 入力 → ドラッグ提出。
Reveal フェーズでカードが順に flip。成功・失敗両ケースを確認。
マグネット挙動（カードを位置間でゆっくり移動）を目視。
Pixi モード OFF（DOM）で同じ操作を実施し、挙動差がないことを確認。
主要ブラウザ（Chrome/Edge）と 125% DPI でチェック。
Performance（DevTools）で fps/CPU 使用率を記録。
この指示に沿って実装すれば、既存ロジックを壊さずに Pixi HUD 化されたカード表示（回転演出込み）が完成します。必要に応じて追加情報をリクエストしてください。