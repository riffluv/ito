Codex用指示文: ロビー退出処理の不具合修正

概要

Firestore上でのロビー退出処理に不具合があり、以下の3点の問題が確認されています
GitHub
。本修正では、ブラウザを閉じた際にも確実に退出処理を行う仕組みを導入し、「退出」ボタン押下時の処理を信頼性向上のために改良します。また、退出処理が失敗した場合でもUIが不整合にならないよう対策します。修正にあたっては、FirestoreのプレイヤーDocument削除とホスト引継ぎ処理、UI遷移の非同期制御を適切に行います。以下に詳細な問題と修正方針を示します。

問題の詳細

ブラウザを閉じた際のゴーストプレイヤー残留: ユーザーがブラウザタブを閉じる/リロードするなど手動退出しなかった場合、他の参加者のロビー画面にそのユーザー名が残り続けます。これはFirestore上のプレイヤーDocが削除されず残存するためで、結果として「ゴーストプレイヤー」が参加者一覧に表示されてしまいます
GitHub
。現在の実装ではページ終了時にRTDBのpresenceからは除名しますが、Firestoreのplayersコレクションからユーザーデータ削除を行っていないためです
GitHub
。

「退出」ボタン押下時に退室できないことがある: ロビー画面の「退出」ボタン(onLeaveRoom)をクリックしても、稀にホーム画面に戻らず退出処理が完了しないケースがあります。調査したところ、退出処理関数leaveRoom内でFirestore更新をawaitしている間に何らかの原因（ネットワーク遅延やFirebase処理停滞）が発生すると、UI遷移がブロックされてユーザーが部屋に留まってしまうようです。現在のコードでは、退出時にFirestoreからプレイヤーDocを削除し各種更新を行った後、router.push("/")でホームへ遷移しています
GitHub
GitHub
。しかしこれら処理を**逐次的（同期的）**に実行しているため、Firestore操作が完了しないと画面遷移もしない構造になっています。その結果、処理失敗時には次の問題(3)が発生します。

退出失敗時にフッター操作パネルが消えたままになる: 上記(2)の状況で退出処理が途中失敗すると、ユーザーは依然としてルームページに留まっているのに、自身の操作UI（フッターのMiniHandDockパネル）が消えてしまう不具合があります。これは「退出」処理の途中でFirestore上のプレイヤーDoc削除だけ実行され、クライアントは自分自身をplayers一覧から除外された状態になるためです。コード上も、playersから自分のIDが無くなるとmeがundefinedとなり、Footパネル（MiniHandDock）が表示されなくなります
GitHub
GitHub
。本来であればその時点でホーム画面に遷移すべきですが、(2)の理由で遷移していないため、ユーザー操作不能の状態に陥っています。

修正対象ファイルと関数

app/rooms/[roomId]/page.tsx:

leaveRoom 関数（退出ボタンのハンドラ）
GitHub

上記関数内で利用しているtransition.navigateWithTransitionコールバック、およびフォールバック処理（router.pushを含む箇所）
GitHub
GitHub

lib/hooks/useLeaveCleanup.ts:

ページ終了時のクリーンアップ処理フック。beforeunloadやpagehideイベントで呼ばれるperformCleanup関数
GitHub

functions/src/index.ts (新規コード追加):

RealTime Database上のPresenceデータをトリガーとしてFirestoreのプレイヤーDoc削除とルーム情報更新を行うクラウド関数（onDisconnectハンドラに相当）を追加します。

修正方針
1. ブラウザ閉鎖時の自動退出処理の導入

Firestoreに残ってしまうゴーストプレイヤー対策として、RTDBのプレゼンス削除イベントに連動してFirestoreのプレイヤーDocを削除します。FirebaseのCloud Functionsを利用し、/presence/{roomId}/{uid}ノードが全て削除されたタイミング（=ユーザーがそのルームから切断された時）で以下の処理を自動実行します。

該当ユーザーのFirestoreドキュメント(/rooms/{roomId}/players/{uid})を即時に削除します（存在しない場合はスキップ）。

ルームドキュメント(/rooms/{roomId})を取得し、以下をトランザクション内で更新します:

もしroom.hostId === uid（離脱者がホスト）であれば、残存プレイヤーの中から新しいホストを決定しhostIdに設定します。可能であればまだオンライン状態のユーザーを優先し、見つからない場合は最初の残存者をホストにします（残存者がいなければhostId自体を削除します）。

ルーム状態中の配列から離脱ユーザーのIDを除去します。具体的には、deal.players配列から当該UIDをフィルタリングし、order.listおよびorder.proposalからも該当UIDを削除します
GitHub
GitHub
。これによりゲーム進行中であっても整合性が保たれます。

残存プレイヤー数を確認し、誰もいなくなった場合はルームを待機状態にリセットします。すなわち、statusを"waiting"に戻し、ゲーム中の一時情報（result, deal, order等）をすべてクリアします
GitHub
。他プレイヤーがいない場合はゲームを強制リセットして部屋を開放し、次回参加者が問題なく利用できるようにします。

システムメッセージを送信します: 離脱したユーザー名（表示名）を含む「〇〇さんが退出しました」というメッセージ、ならびにホストが変更された場合「👑 ホストが〇〇さんに委譲されました」メッセージを、該当ルームのチャットに記録します
GitHub
GitHub
（ホスト委譲時）。ホスト変更が行われず部屋リセットとなった場合は「🔄 部屋が空になったため、ゲーム状態をリセットしました」のメッセージを送ります
GitHub
。これらにより他の参加者にも状態変化が周知されます。

実装: 上記はFirebaseのRTDBトリガー（例えばfunctions.database.ref("presence/{roomId}/{uid}").onWrite）として実装します。change.after.exists() == false（該当ユーザーのpresenceノードが削除された）場合にのみ処理を行うよう条件分岐してください。なお、Cloud Functions内では管理者権限でFirestore操作を行うため、セキュリティルールを気にせずプレイヤーDoc削除やホストID更新が可能です。

この自動退出処理により、ユーザーがブラウザを閉じたり回線切断しても即座にFirestore上から退室扱いとなります。他参加者のUI上もplayersコレクションから該当ユーザーが削除されることで、ゴーストが表示されなくなります。

2. 「退出」ボタン処理の非同期化と信頼性向上

「退出」ボタンを押した際のleaveRoom処理を見直し、画面遷移をブロックしない非同期処理に変更します。具体的な修正内容は以下の通りです。

UI遷移とFirestore削除の分離: 現状はleaveRoom関数内でawait leaveRoomAction(roomId, uid, displayName)としてFirestore更新完了を待ってから画面遷移しています
GitHub
。これを改め、Firestoreの削除・更新処理をバックグラウンドで実行しつつ、即座にホーム画面へ遷移するようにします。

方法1: transition.navigateWithTransitionのコールバック内で非同期処理をawaitせず実行し、コールバック関数自体を迅速に完了させます。例えば、コールバック関数からasyncキーワードを外し、内部でdetachNow()やleaveRoomAction()を呼ぶ際に.catch()を付けてエラーを握りつぶしつつPromiseを開始します（結果を待たない）。こうすることで、ロード画面の演出時間終了後には確実にnavigateWithTransitionが完了し、ホーム画面への遷移が実行されます。現行コードのようにPromiseを返さなければ、transitionは内部の1.2秒間のローディング後に自動的にresolveし、以降の処理が進みます。

方法2: Next.jsのAPIルートPOST /api/rooms/[roomId]/leaveを利用する方法です。ボタン押下時にまずgetIdToken()で取得したJWTトークン等を含むリクエストをこのAPIに送り、レスポンスを待たずにrouter.push("/")で画面遷移します。API側（サーバー）ではleaveRoomServerを呼んでFirestore処理を行うため、クライアントは速やかにUI遷移でき、バックエンドで確実に退室処理が完了します。こちらの方法ではnavigator.sendBeaconを使うことも検討できます（ページ遷移中もリクエストを継続させるため）。ただし、トークン取得の非同期やエラーハンドリングの実装コストを考慮し、方法1のUIスレッド上で完結する実装でも十分と判断します。

フォールバック処理の修正: transitionコンテキストが存在しない場合（elseブロック）も同様に、detachNowやleaveRoomActionをawaitせず即座にrouter.push("/")を呼ぶよう修正します
GitHub
。detachNow()とforceDetachAll()、leaveRoomAction()はtry/catch内で呼び出し、エラーはログに記録するだけに留めて処理継続します。こうすることで、たとえFirestore削除が失敗した場合でもUI遷移は妨げられません。

これらの変更により、ユーザーが「退出」ボタンを押した際は常に速やかにホーム画面へ戻るようになります。Firestore側の退出処理は裏で継続しますが、仮に失敗しても上記Cloud Function (1) の仕組みで最終的に退室状態が保証されます。

3. 退出失敗時のUI不整合対策

非同期化によってほぼ解消されますが、万一退出処理が失敗・遅延した場合でもUIが不整合にならないようガードを追加します。

手動退出処理時: (2)の改修で画面遷移をブロックしないため、基本的に「プレイヤーDoc削除済みでルームページに留まる」状態そのものが発生しなくなります。ユーザー視点ではボタン押下後直ちにルームを離れるため、不整合は生じません。

予期せぬ残留時のチェック: 念のため、クライアント側useRoomStateまたはページコンポーネントで、自分自身のプレイヤーDocが存在しないのにまだルームページにいるという状態を検知したら自動的にホームへリダイレクトする処理を追加してもよいでしょう。具体的には、players配列から自分のUIDが見つからない場合（isMember == false）、router.replace("/")を呼ぶガードを設けます（部屋ステータスがwaitingの場合も想定し、ホストでなくメンバーでもないなら退出済みとみなす）。このガードにより、万一Firestore削除だけ行われてしまった場合でも即座にメインメニューへ復帰できます。

leavingRefの活用: 既存のleavingRefフラグは「退出処理中」であることを示しています
GitHub
。手動退出時にleavingRef.current = trueとしていますが
GitHub
、このフラグが立っている場合は再入室処理を行わないなどの制御がすでになされています
GitHub
。今回の改修でもleavingRefは適宜活用し、二重処理防止やガード判定に用いてください。例えば、Cloud Functionによる自動退出実行前に既にleavingRef.currentがtrueであれば（手動退出が走っていた場合）、関数側ではFirestore削除が二重で行われないようにします（もっとも、本件ではpresenceトリガー内でFirestore側の該当Docが削除済みならスキップする設計としています）。

以上の対策により、退出処理が失敗したケースでもユーザーが部屋に取り残されることは無くなり、UI要素が消えたまま操作できないといった問題も解消されます。

その他要件

テストと検証: 修正後は以下のシナリオを重点的にテストしてください。

ユーザーがブラウザを直接閉じた場合でも、約定通り他クライアントの参加者一覧から即座に削除されること（ゴーストプレイヤーが残らないこと）。複数タブで同一ユーザーが接続していた場合など、RTDB上の最後の接続が切れた時点で処理が発動する点にも留意します。

「退出」ボタン押下で確実にメインメニューに遷移できること。ネットワークを意図的に遮断・遅延させた環境で試し、遷移がブロックされないか確認します。必要に応じて遷移処理にタイムアウトを設けることも検討してください。

ホストユーザーが異常切断したケースでのホスト引継ぎを確認します。他の参加者の画面で新しいホスト表示に更新され、ホストのみの操作（ゲーム開始など）が正常に可能になることをチェックしてください。ホスト不在時は自動リセットメッセージが送られゲームが待機状態に戻ることも確認しましょう。

手動退出と自動退出が競合した場合の冪等性を確認します（例えば「退出」ボタンを押した直後にブラウザを閉じる操作）。この場合でも一度しかFirestore削除やホスト変更が行われず、システムメッセージの重複送信がないことを期待します。

セキュリティと性能: Cloud Function導入によりFirestoreへの書き込みが増えますが、退出時のみの低頻度処理のため性能影響は限定的です。念のためFunctions内では不要なルックアップや重い演算を避け、get()したデータの二次利用やbatch操作の活用で効率を確保してください。セキュリティ面では、クライアントからの削除リクエストを待たずサーバーサイドで強制退出させるため、悪意あるクライアントが意図的に居残ろうとするケースも防げます。

コードの可読性: 修正箇所では、コメントを添えて退出処理の流れを明示してください。特にleaveRoom関数の非同期処理部分は将来のメンテナンス時に誤解が生じやすいので、「画面遷移を即時実行し、Firebase処理はバックグラウンドで実施している」旨をコメントで説明すると良いでしょう。

以上の修正により、ロビー退出処理の不具合3点（ゴーストプレイヤー残留、退出操作無反応、UI消失）の解消を図ります。修正後のコードは、全ての想定シナリオで退出処理が一貫して正しく動作すること
GitHub
を確認してください。ソース管理上、新規追加するCloud Functionやロジックの変更部分について適切に差分を作成し、関連するドキュメント（例えばFirebase仕様書など）があればアップデートを行ってください。

 

参考: 現在の実装では退出処理でplayersコレクションのドキュメント削除後、クライアント側でmeが存在しなくなりFootパネルが非表示になる設計ですが
GitHub
GitHub
、今回の修正によりその状態になる前に画面遷移させるか、あるいはサーバー側で早期にDoc削除するため、この挙動はユーザーに知覚されなくなります。今後も同種のリアルタイム性が要求される処理では、RTDBのonDisconnectやCloud Functionsを活用し、クライアントの状態管理と整合させていく方針です。

 

ソース: ロビー退出処理の要件と現行実装の問題点は、プロジェクトの検証指示書
GitHub
およびコードベースから確認できます（退出処理の期待挙動
GitHub
、現在のcleanup処理
GitHub
、退出ボタン処理
GitHub
）。今回の修正はそれらを踏まえた改善となります。

 <!-- Citations --> 

GitHub
 ロビー検証指示書（退出処理でゴーストが残らないことを期待）

GitHub
 useLeaveCleanup.ts（ページ終了時、RTDBからの削除は行うがFirestore削除がない現状）

GitHub
 page.tsx（退出時、Firestore操作完了までUI遷移を待機している問題箇所）

GitHub
GitHub
 page.tsx（自分のプレイヤーDoc消失時にフッターパネルが非表示になる実装）